---
description: 
globs: 
alwaysApply: false
---
# Testing Rules and Best Practices

## File Organization

- All test files should be placed in the centralized `src/tests` directory
- Test files should mirror the source directory structure:
  ```
  src/
  ├── components/
  │   └── ui/
  │       └── Button.tsx
  └── tests/
      └── components/
          └── ui/
              └── Button.test.tsx
  ```
- Test files should be named with `.test.ts` or `.test.tsx` extension
- Test directories should match source directories:
  - `src/components/*` → `src/tests/components/*`
  - `src/lib/*` → `src/tests/lib/*`
  - `src/app/api/*` → `src/tests/api/*`

## Test Categories

### Unit Tests
- Test individual components/functions in isolation
- Mock external dependencies
- Focus on specific functionality
- Example: Testing a Button component's rendering and click behavior

### Integration Tests
- Test how components work together
- Test API endpoints and data flow
- Example: Testing the interaction between a form and its submission handler

### E2E Tests
- Test complete user flows
- Use tools like Cypress or Playwright
- Example: Testing the complete login flow

## Test Structure

```typescript
describe('ComponentName', () => {
  // Setup and teardown
  beforeEach(() => {
    // Common setup
  });

  afterEach(() => {
    // Cleanup
  });

  // Test categories
  describe('rendering', () => {
    it('should render correctly', () => {
      // Test code
    });
  });

  describe('interactions', () => {
    it('should handle user events', () => {
      // Test code
    });
  });

  describe('edge cases', () => {
    it('should handle error states', () => {
      // Test code
    });
  });
});
```

## Testing Best Practices

### Component Testing
- Use `@testing-library/react` for component testing
- Test user interactions with `userEvent` instead of `fireEvent`
- Test accessibility where applicable
- Test both success and error states
- Test edge cases and boundary conditions

### API Testing
- Mock external API calls
- Test different response scenarios
- Test error handling
- Test loading states

### State Management Testing
- Test state updates
- Test state persistence
- Test state synchronization

## Mocking Guidelines

### Function Mocking
```typescript
// Mock a function
const mockFn = jest.fn();

// Mock a module
jest.mock('@/lib/module', () => ({
  function: jest.fn(),
}));

// Spy on a method
jest.spyOn(object, 'method');
```

### API Mocking
```typescript
// Mock fetch
global.fetch = jest.fn().mockResolvedValue({
  ok: true,
  json: () => Promise.resolve(data),
});
```

## Test Coverage

- Aim for high coverage of critical paths
- Focus on testing behavior, not implementation
- Test edge cases and error conditions
- Minimum coverage requirements:
  - Statements: 80%
  - Branches: 80%
  - Functions: 80%
  - Lines: 80%

## Common Test Patterns

### Component Testing
```typescript
describe('Component', () => {
  it('renders correctly', () => {
    render(<Component />);
    expect(screen.getByRole('button')).toBeInTheDocument();
  });

  it('handles user interaction', async () => {
    const user = userEvent.setup();
    render(<Component />);
    await user.click(screen.getByRole('button'));
    expect(mockFn).toHaveBeenCalled();
  });
});
```

### API Testing
```typescript
describe('API', () => {
  it('handles successful response', async () => {
    mockFetch.mockResolvedValueOnce({ ok: true, data: {} });
    const result = await apiCall();
    expect(result).toBeDefined();
  });

  it('handles error response', async () => {
    mockFetch.mockRejectedValueOnce(new Error('API Error'));
    await expect(apiCall()).rejects.toThrow('API Error');
  });
});
```

## Accessibility Testing

- Test keyboard navigation
- Test screen reader compatibility
- Test ARIA attributes
- Test focus management

## Performance Testing

- Test component rendering performance
- Test state update performance
- Test API call performance
- Use React Profiler for performance measurements

## Continuous Integration

- Run tests on every pull request
- Enforce minimum coverage requirements
- Run different test categories in parallel
- Cache test results for faster CI runs



